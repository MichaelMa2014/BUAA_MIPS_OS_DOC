
Lab3 实验报告
----------------
### 理解和填写代码

最困难的函数应该是 ` load_icode_mapper() ` 

这个函数需要做到把规定的一段内容保存到从 ` va ` 开始的虚拟地址中。而 ` va ` 不一定是一个对齐到页的地址。由于之前编写的内存管理方式是按页管理，那么 ` va ` 所在的这一页会不会有其他的数据呢？首先，如果有，那么这些数据只能放弃，因为每一个物理页面只有一个页表项可以指向它（因为 ` page_insert() ` 函数首先检查是否存在页表项，如果有已经指向这个物理页面的，则先把它删掉）。

其次，事实上调用 ` load_icode_mapper() ` 的 ` load_elf() ` 函数需要根据 ELF 文件来决定 ` va ` ，所以编译器需要保证丢失的（不到一页）数据不会造成危害。

### 研究思考题

#### Thinking 3.1 为什么我们在构造空闲进程链表时使用了逆序插入的方式?

由于在链表中插入元素只能使用 ` LIST_INSERT_HEAD ` 宏，只有逆序插入才能保证 ` envs ` 数组的第一个元素在 ` env_free_list ` 的头部。

#### Thinking 3.2 思考 ` env_setup_vm ` 函数

- 从 ` i = UTOP ` 开始执行了 ` pgdir[i] = boot_pgdir[i] ` ，是因为高于 ` 2G ` 的虚拟地址对所有进程来说都对应相同的物理地址。这部分所有进程的页表的内容都是一样的，因此需要让每个进程的页目录中对应这部分的项都指向同一片页表，也和就是 ` boot_pgdir ` 相同。

- ` ULIM ` 的含义是用户虚拟地址的最大值， ` UTOP ` 的含义是用户可以修改的虚拟地址的最大值，这两个值之间的虚拟地址映射的物理地址是系统管理物理页面的 ` Pages ` 数组、管理进程的 ` Envs ` 数组和当前进程的页表，这部分虚拟地址和内核虚拟地址的一部分映射到同一片物理地址空间。

- ` env_cr3 ` 中保存的是当前进程页目录的物理地址，而页表中有一项是应该映射到这个物理地址的，这一项同样也是页目录中的一项，也就是第 ` PDX(UVPT) ` 项，又由于上文提到的， ` VPT ` 和 ` UVPT ` 两个虚拟地址映射到了同一个物理地址，所以第 ` PDX(VPT) ` 项也应该赋值为 ` env_cr3 ` 。


#### Thinking 3.3  ` user_data ` 的作用

由于在设置虚拟地址到一段数据的映射时一定要用到当前进程的页表，所以 ` user_data ` 应该是用来传递指向页表的指针的。

#### Thinking 3.4 位置的含义

- 我觉得指令位置是针对虚拟地址空间，因为 CPU 访问用户空间的内存总是要通过 MMU，而此时只有使用虚拟地址才能正确访问到想要的数据。
- ` entry_point ` 的值应该是连接器写在 ELF 文件里的，而连接器是根据 linker script 确定这个值应该是多少的，所以不是每个进程都一样。
- 最可能或者说默认的这个值应该是 ` UTEXT ` 处，因为这是程序代码段的开始。

#### Thinking 3.5 进程上下文的 ` PC ` 值

我认为应该是此时 CP0 寄存器中保存的 EPC 值，因为这是由硬件保存的，发生中断时的 PC 值，也就是当前进程上下文的 PC 值。

#### Thinking 3.6  ` TIMESTACK ` 的含义

-  ` TIMESTACK ` 是发生时钟中断时 CPU 把现场保存到内存中的位置。

-  设置 ` KERNEL_SP ` 的值只发生在一处，也就是在 ` kclock.c ` 文件中的 ` set_timer() ` 函数，而这个函数是一个汇编函数，其中一条语句就是把当前 CPU 的 ` $sp ` 寄存器保存到 ` KERNEL_SP ` 处。也就是说， ` KERNEL_SP ` 保存的是设置计时器时 CPU 栈指针的值。而在 ` env_destroy() ` 函数中有一条语句，是把从 ` KERNEL_SP ` 开始的大小为一个 ` Trapframe ` 结构的内容保存到了 ` TIMESTACK ` 处。那么此处的数据为什么就一定是一个 ` Tramframe ` 结构呢？是由谁保存在这里的呢？又是谁区分了 ` TIMESTACK ` 和 ` KERNEL_SP ` 这两处的内容呢？

-  应该是中断处理程序。 ` handle_int() ` 这个汇编函数就是用来处理硬件中断的，其中调用的 ` SAVE_ALL ` 这个宏完成了把当前 CPU 所有寄存器按照 ` Trapframe ` 结构的格式保存到内存中的任务，然而要小心注意到 ` get_sp ` 这个宏。这个宏会判断当前中断的原因，如果是时钟中断，则把当前的栈指针改到了 ` TIMESTACK ` 处，也就是

   ```c
    li	sp, 0x82000000
   ```

-  而 ` 0x82000000 ` 正是 ` TIMESTACK ` 的值。

   ```c
    #define TIMESTACK 0x82000000
   ```


- 而如果不是时钟中断，则把栈指针改到 ` KERNEL_SP ` 处。
- 综上所述，如果发生了时钟中断，当前现场保存到 ` TIMESTACK ` ，否则保存到 ` KERNEL_SP ` 。

#### Thinking 3.7 不公的调度

我觉得主要的不公平体现在对 CPU 密集型的进程，因为它每次都会用满自己的时间片，然后等待其他所有进程执行一遍，但是在等待的时候什么工作都不能做。而对于 I/O 密集型的进程，每次用不满时间片，但是在轮转到其他进程的时候，它可以进行 I/O 操作，所以周转时间要明显比 CPU 密集型的进程短。当然这个问题是没办法解决的，除非换用更加精明的调度算法。

我注意到金晖明同学的实验报告中提到，一个进程的时间片会被用来遍历其他所有进程控制块，这是一个问题但是不能称作“不公平”，因为事实上每个进程的时间片都有可能被操作系统用来做一些辅助操作，而这个“受害者”进程的选择是随机的。当然在这个实验中，第一个进程被打断后，占用第二个进程的时间片进行遍历的时间很短（因为很快就能找到现在可以运行的进程，也就是第二个进程），而第一个进程运行前则需要遍历所有进程控制块，时间较长。这是一种不公平，但是这种不公平只发生在有很多不可运行的进程，而且两个可以运行的进程都是没有 I/O 的。当然这种不公平可以通过减少进程控制块总数来避免。比如令 ` NENV ` 等于 2。


### 难度评估

这次实验我觉得不是很难，需要做的有一些是需要耐心不需要智力的工作。但是这次没能在现场测试之前完成，主要是我自己的原因。总共用了大约 20 小时，3.5 小时用于写作实验报告，其余时间主要是阅读已有代码和指导书，少量时间用于填写代码。